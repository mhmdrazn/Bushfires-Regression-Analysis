# -*- coding: utf-8 -*-
"""bushfires-regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wgK9lV8UGBV6JCpvdEsnqh2VVYaHW7L1

# Import Dataset
"""

import pandas as pd

# read the dataset
dt = 'https://raw.githubusercontent.com/mhmdrazn/regression-bushfires/main/Bushfires%20Dataset'
dataset = pd.read_csv(dt, delimiter= ",", encoding = "utf-8")

dataset.head()

"""# Data Preprocessing

## 1. Convert Temperature and Wind Speed to numerical values
"""

# Convert temperature and wind speed columns to numerical values
dataset['Minimum temperature (°C)'] = dataset['Minimum temperature (°C)'].str.replace(',', '.').astype(float)
dataset['Maximum temperature (°C)'] = dataset['Maximum temperature (°C)'].str.replace(',', '.').astype(float)
dataset['Speed of maximum wind gust (km/h)'] = dataset['Speed of maximum wind gust (km/h)'].str.replace(',', '.').astype(float)

dataset.head()

"""## 2. Encode categorical variables "Direction" using one-hot encoding or label encoding

"""

# Encode categorical variables
from sklearn.preprocessing import LabelEncoder

# Encode 'Direction' columns
label_encoder_direction = LabelEncoder()
dataset['Direction'] = label_encoder_direction.fit_transform(dataset['Direction Max Wind Gust'])

# Display the first few rows to check the encoding
dataset[['Status', 'Direction']].head()

# SAFE : 1
# ADVICE : 2
# WATCH AND ACT : 3
# BURNT : 4
# EMERGENCY WARNING : 5

dataset.head()

"""## 3. Handle missing values"""

# Handle missing values (e.g., fill with mean or median, or drop rows)
dataset = dataset.dropna()

# Display the first few rows to ensure no missing values
dataset.head()

dataset.info()

"""# Checking Outliers"""

import matplotlib.pyplot as plt
import seaborn as sns

# checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Minimum temperature (°C)")

plt.subplot(1,2,2)
sns.boxplot(data=dataset, y="Maximum temperature (°C)")

plt.show()

# checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Evaporation")

plt.subplot(1,2,2)
sns.boxplot(data=dataset, y="Speed of maximum wind gust (km/h)")

plt.show()

"""# Removing Outliers"""

# Calculates Q1 (25th percentile) and Q3 (75th percentile)
Q1 = dataset['Minimum temperature (°C)'].quantile(0.25)
Q3 = dataset['Minimum temperature (°C)'].quantile(0.75)
IQR = Q3 - Q1
# Determine the upper and lower limits for detecting outliers
lower_bound = Q1 - 1.5*IQR
upper_bound = Q3 + 1.5*IQR

# Removing outliers
dataset = dataset[(dataset['Minimum temperature (°C)'] >= lower_bound) & (dataset['Minimum temperature (°C)'] <= upper_bound)]

# Checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Minimum temperature (°C)")
plt.show()

# Calculates Q1 (25th percentile) and Q3 (75th percentile)
Q1 = dataset['Maximum temperature (°C)'].quantile(0.25)
Q3 = dataset['Maximum temperature (°C)'].quantile(0.75)
IQR = Q3 - Q1
# Determine the upper and lower limits for detecting outliers
lower_bound = Q1 - 1.5*IQR
upper_bound = Q3 + 1.5*IQR

# Removing outliers
dataset = dataset[(dataset['Maximum temperature (°C)'] >= lower_bound) & (dataset['Maximum temperature (°C)'] <= upper_bound)]

# Checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Maximum temperature (°C)")
plt.show()

# Calculates Q1 (25th percentile) and Q3 (75th percentile)
Q1 = dataset['Evaporation'].quantile(0.25)
Q3 = dataset['Evaporation'].quantile(0.75)
IQR = Q3 - Q1
# Determine the upper and lower limits for detecting outliers
lower_bound = Q1 - 1.5*IQR
upper_bound = Q3 + 1.5*IQR

# Removing outliers
dataset = dataset[(dataset['Evaporation'] >= lower_bound) & (dataset['Evaporation'] <= upper_bound)]

# Checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Evaporation")
plt.show()

# Calculates Q1 (25th percentile) and Q3 (75th percentile)
Q1 = dataset['Speed of maximum wind gust (km/h)'].quantile(0.25)
Q3 = dataset['Speed of maximum wind gust (km/h)'].quantile(0.75)
IQR = Q3 - Q1
# Determine the upper and lower limits for detecting outliers
lower_bound = Q1 - 1.5*IQR
upper_bound = Q3 + 1.5*IQR

# Removing outliers
dataset = dataset[(dataset['Speed of maximum wind gust (km/h)'] >= lower_bound) & (dataset['Speed of maximum wind gust (km/h)'] <= upper_bound)]

# Checking outliers
plt.figure(figsize=(15,5))

plt.subplot(1,2,1)
sns.boxplot(data=dataset, y="Speed of maximum wind gust (km/h)")
plt.show()

"""# Define and Train Model

## Split the Data into training and testing sets
"""

from sklearn.model_selection import train_test_split

# Select the feature columns and the target column
features = ['Minimum temperature (°C)', 'Maximum temperature (°C)', 'Evaporation', 'Speed of maximum wind gust (km/h)']
target = 'Status'

# Split the data into training and testing sets
X = dataset[features]     #dependent
y = dataset[target]       #independent

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

X_train.head(), y_train.head()
print(X_train)
print(y_train)

"""##Train the model"""

import numpy as np
from math import pi
from sklearn.linear_model import LinearRegression
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import mean_squared_error

# Model Training
# Fit a logistic regression model
model = LinearRegression()
model.fit(X_train, y_train)

"""## Make a prediction"""

import numpy as np
from math import pi
from sklearn.linear_model import LinearRegression
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import mean_squared_error

# Make predictions
y_pred = model.predict(X_test)
print(y_pred)

"""# Evaluate the model

"""

mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
print(f'Root Mean Squared Error: {rmse}')

"""# Visualize the Model"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))

plt.scatter(X_test['Evaporation'], y_pred, alpha=0.6, color='b')

plt.plot([min(X_test['Evaporation']), max(X_test['Evaporation'])], [min(y_pred), max(y_pred)], color='r', linestyle='--')
plt.xlabel('Evaporation')
plt.ylabel('Status')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))

plt.scatter(X_test['Speed of maximum wind gust (km/h)'], y_pred, alpha=0.6, color='b')

plt.plot([min(X_test['Speed of maximum wind gust (km/h)']), max(X_test['Speed of maximum wind gust (km/h)'])], [max(y_pred), min(y_pred)], color='r', linestyle='--')
plt.xlabel('Speed of maximum wind gust (km/h)')
plt.ylabel('Status')
plt.grid(True)
plt.show()

from sklearn.metrics import r2_score

# Assuming y_true are the actual values and y_pred are the predicted values
r2 = r2_score(y_test, y_pred)
print(f"R-squared: {r2}")

import matplotlib.pyplot as plt
import seaborn as sns

# Membuat figure
plt.figure(figsize=(10, 6))

# Membuat scatter plot
plt.scatter(X_test['Evaporation'], y_pred, alpha=0.6, color='b')

# Menambahkan garis referensi
plt.plot([min(X_test['Evaporation']), max(X_test['Evaporation'])], [min(y_pred), max(y_pred)], color='r', linestyle='--')

# Mengatur label sumbu x dan y
plt.xlabel('Evaporation')



# Mengatur nilai diskret dan label untuk sumbu y
plt.yticks([1, 2, 3, 4, 5], ['SAFE', 'ADVICE', 'WATCH AND ACT', 'BURNT', 'EMERGENCY WARNING'])

# Menampilkan grid
plt.grid(True)

# Menampilkan plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))

plt.scatter(X_test['Speed of maximum wind gust (km/h)'], y_pred, alpha=0.6, color='b')

plt.plot([min(X_test['Speed of maximum wind gust (km/h)']), max(X_test['Speed of maximum wind gust (km/h)'])], [max(y_pred), min(y_pred)], color='r', linestyle='--')
plt.xlabel('Speed of maximum wind gust (km/h)')

# Mengatur nilai diskret dan label untuk sumbu y
plt.yticks([1, 2, 3, 4, 5], ['SAFE', 'ADVICE', 'WATCH AND ACT', 'BURNT', 'EMERGENCY WARNING'])

plt.grid(True)
plt.show()